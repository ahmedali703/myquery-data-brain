# MyQuery Data Brain

## Overview
This project contains the front-end JavaScript, PL/SQL processes, and database objects that power the **MyQuery AI dashboard builder** built on Oracle APEX.  The application takes a natural-language question, plans a dashboard layout with the help of OpenAI, generates the required SQL/KPI/summary content, and renders an interactive, presentation-friendly view in the browser.

The repository is organised as a set of Oracle APEX page processes (each exported as a `.sql` file), JavaScript assets that run in the browser, and database DDL used to provision persistent storage for dashboards, widgets, and related metadata.  By reviewing each artifact you can see the full end-to-end flow from user input to rendered dashboard.

## Front-end assets
| File | Description |
| --- | --- |
| `execute.js` | Bootstraps the left navigation tree in APEX, periodically calls the `GET_SIDE_MENU` process, and keeps menu items in sync with the server-provided `is_current` flag.  It also handles client-side highlighting and clears cached intervals on reload. |
| `functions.js` | Encapsulates the browser logic for Page 3 (dashboard builder).  It shows a progress HUD, orchestrates the sequence of APEX AJAX calls (`DASH_PLAN` → `DASH_CREATE_BLOCKS` → KPI/insight/summary/overview/chart/finalize steps), and renders the resulting header, overview, KPI cards, chart, and key insights using the AI-generated metadata.  Chart visualisation relies on Chart.js loaded on demand. |

## Server-side processes (APEX AJAX callbacks)
Each `.sql` file corresponds to a named process invoked through `apex.server.process` in `functions.js`:

| Process | Purpose |
| --- | --- |
| `DASH_PLAN.sql` | Calls `myquery_dashboard_ai_pkg.plan_layout_and_blocks` to generate a JSON plan describing the dashboard title, block layout, and SQL hints.  Validates the JSON before returning it to the browser. |
| `DASH_CREATE_BLOCKS.sql` | Persists the planned blocks by inserting dashboard and widget rows (via package procedures) and returns the dashboard identifier. |
| `DASH_GEN_KPIS.sql` | Enriches the dashboard with KPI widgets generated by the AI package. |
| `DASH_GEN_INSIGHTS.sql` | Produces textual insights for the dashboard and stores them against the widget metadata. |
| `DASH_GEN_SUMMARY.sql` | Creates a brief textual summary used in the title area. |
| `DASH_GEN_OVERVIEW.sql` | Generates the overview narrative displayed in the Overview card. |
| `DASH_GEN_CHART.sql` | Builds a chart-focused widget, including structured chart data plus bullet insights, and writes them to the widget’s `visual_options`. |
| `DASH_FINALIZE.sql` | Performs post-processing/cleanup after all AI content has been generated. |
| `GET_DASH_META.sql` | Returns the consolidated dashboard metadata (title, subtitle, overview text, KPI payloads, chart configuration, insights, etc.) that `functions.js` uses to render the page. |
| `GET_SIDE_MENU.sql` | Delegates to `myquery_smart_query_pkg.get_side_menu_proc` to obtain the navigation tree (chat history, dashboards) for the left-hand menu. |

## Database objects
`Database.sql` provisions the relational layer that stores dashboards and their components:

- `DASHBOARDS`, `WIDGETS`, and associated triggers capture the top-level dashboard definition and each widget’s SQL/visual configuration.
- `DASHBOARD_FILTERS`, `DASHBOARD_SHARES`, and `DASHBOARD_VERSIONS` support filtering, sharing, and historical snapshots.
- `SMART_QUERY` and `SYS_USERS` store chat/query history and application user credentials.
- `SEND_REPORT_MAIL_LOG` provides logging for email delivery.

All tables use identity columns, timestamps, and foreign key relationships aligned with cascading deletes for dependent records.

## AI orchestration package
`MYQUERY_DASHBOARD_AI_PKG.sql` defines the PL/SQL package used by the page processes:

- Builds prompts for OpenAI’s Responses API (`gpt-4o-mini` by default) and parses JSON responses.
- Provides helper routines to sanitise SQL, escape JSON, and enforce select-only queries before persisting them.
- Exposes public procedures for planning layouts, generating KPIs, producing chart SQL + configuration, and writing overview/summary text.  These procedures take the user’s natural-language question and optional schema name so the AI can operate within the correct Oracle schema context.

## Runtime flow
1. A user enters a question and triggers `runDashboardBuilder()` from `functions.js`.
2. The browser shows a progress HUD and sequentially calls the APEX processes.  Each process delegates to `myquery_dashboard_ai_pkg` to interact with OpenAI and store structured results in the Oracle tables.
3. After finalisation, the client fetches metadata via `GET_DASH_META` and renders:
   - Header/title block (title derived from the user’s question).
   - Overview narrative with optional KPI cards.
   - Chart visualisation with accompanying insights.
4. The side navigation (`execute.js`) refreshes every 10 seconds to reflect dashboard history and the current selection.

## Prerequisites & configuration
- Oracle APEX application with the described AJAX processes and supporting items (`P3_QUESTION`, `P3_PLAN_JSON`, `P3_DASH_ID`, `P0_DATABASE_SCHEMA`).
- A REST credential named `credentials_for_ai_services` configured with an OpenAI API key that permits use of the Responses endpoint.
- Network access from the Oracle database to `https://api.openai.com`.
- Chart.js 4.x available to the browser (loaded dynamically by `functions.js`).

## Development notes
- All AI responses are validated before persisting; fallbacks prevent empty dashboards when the model fails to return valid JSON.
- Client-side rendering removes stale blocks before inserting AI content, ensuring only generated widgets appear.
- KPI and chart renderers include diagnostic logging to help debug malformed AI payloads during development.
- The side menu logic is idempotent and guards against duplicate event handlers by namespacing the delegated click listener.

This documentation is based on the code and SQL scripts included in the repository to aid reverse engineering and onboarding.
